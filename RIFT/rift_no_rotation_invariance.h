#ifndef __RIFT_NO_ROTATION_INVARIANCE_H__
#define __RIFT_NO_ROTATION_INVARIANCE_H__

#include <iostream>
#include <algorithm>
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/cudaimgproc.hpp>
#include <opencv2/calib3d.hpp>
#include "phase.h"

/* RIFT配准主要步骤：
 * step1: Phase congruency 相位一致性 计算PC图，得到类似边缘检测的结果
 * step2: FAST dectector 提取特征点，边缘图->特征点的x,y坐标
 * step3: RIFT descriptor 描述子，每个特征点对应一个特征向量
 * step4: BFmatcher 用暴力算法求解匹配，计算两个图中所有特征点之间的欧氏距离，取距离最小的
 * step5: RANSAC 假设两图符合单应变换模型，利用RANSAC进行误匹配剔除，得到最优的变换矩阵H
 * step6: WarpPerspective 把所得的H和原图A相乘，得到变换后的图A
 * step7: Image fusion 融合规则不属于配准该管的事，这里使用加权平均规则
 * 
 * Inference() : do step1~step5 by calling all the other functions, return H, and leave step6~step7 to outside
 * RIFT_no_rotation_invariance() : do step1 by using phase.h, do step2
 * RIFT_descriptor_no_rotation_invariance() : do step3
 * CalcMatch() : do step4~step5
 */

class RIFT{
public:

    /**
	 * @brief RIFT constructor
	 * @param _s Scales, set as 4
	 * @param _o Orientation, set as 6
	 * @param _patch_size Patch size for RIFT, set as 96
     * @param _thre Threshold for FAST detector
     * @param img_size Image size, use cv::Size(w,h)
	 */
    RIFT(int _s, int _o, int _patch_size, int _thre, cv::Size img_size);

    /**
	 * @brief Calculate Homography Matrix using RIFT. Note: H * point_in_im1 = point_in_im2. 
	 * @param im1 Src image
	 * @param im2 Dst image
	 * @param transMat The result, 3x3 Homography matrix
     * @param id Only useful for debug, can be set as 0
	 */
    void Inference(cv::Mat im1, cv::Mat im2, float transMat[3][3], int id);

    /**
	 * @brief Find key points of an image and calculate their descriptors 
	 * @param img The image to calculate
	 * @param kps The detected key points
     * @result A cv::Mat, each row stand for the descriptor of a key point in kps
	 */
    cv::Mat RIFT_no_rotation_invariance(cv::Mat img, std::vector<cv::KeyPoint> &kps);

    /**
	 * @brief The implementation of descriptor calculation
	 * @param im The image to calculate
	 * @param keypoints Rough keypoints found by FAST detector
     * @param kps The result, filtered keypoints
     * @param eo The EO map generated by phase congruency
     * @result A cv::Mat, each row stand for the descriptor of a key point in kps
	 */
    cv::Mat RIFT_descriptor_no_rotation_invariance(cv::Mat im, std::vector<cv::KeyPoint> keypoints,std::vector<cv::KeyPoint> &kps, std::vector<cv::Mat> eo);

    /**
	 * @brief Calculate Homography Matrix by matching key points in two images
	 * @param des_m1 The descriptors of image 1
	 * @param des_m2 The descriptors of image 2
     * @param kps1 The key points of image 1
     * @param kps2 The key points of image 2
     * @param InlierMatches Only useful for debug, cv::drawMatches() need it
     * @result Homography Matrix, a 3x3 cv::Mat
	 */
    cv::Mat CalcMatch(cv::Mat& des_m1, cv::Mat& des_m2, std::vector<cv::KeyPoint> &kps1, std::vector<cv::KeyPoint> &kps2, std::vector<cv::DMatch>& InlierMatches);

private:
    int s;
    int o;
    int patch_size;
    int thre;
    PhaseCongruency pc;

};

#endif